//
// C++ Interface: openingdatabase_mg
//
// Description:
//
//
// Author: Yizao Wang <yizao.wang@polytechnique.edu>, (C) 2006
//
// Copyright: See COPYING file that comes with this distribution
//
//
#ifndef MOGOOPENINGDATABASE_MG_H
#define MOGOOPENINGDATABASE_MG_H
#include "typedefs_mg.h"
#include <string>
#include "goban_mg.h"

namespace MoGo {
  /**
  Create database for opening. Most part of the codes are done by Sylvain. Normally in the database file, each line consists of one gobanKey and one location (move), and the corresponding values for the black and white. I'm not clear with the value calculations.
  @author Sylvain Gelly
  */
  class OpeningDatabase {
  public:
    OpeningDatabase();

    ~OpeningDatabase();

  };


  class Database3 {
    friend class GoExperiments;
  public:
    Database3(int gobanSize=9, bool useOldFormat=false);
    int indexOfGobanAndMove(const GobanKey &key,int move) ;
    bool isOneRepresentativeOfGobanInDatabase(const Goban &goban) ;
    int nbRepresentativesOfGobanInDatabase(const Goban &goban) ;
    bool isGobanAndMoveInDatabase(const GobanKey &key,int move) ;
    //     void addValue(const Goban &goban, const Location move, double v);
    bool addValues(const Goban &goban, const Location move, double value0, double value1, bool discardOneSimulationGobans=false, bool testIfLegal=true);
    bool addValues(const GobanKey &key, const Location move, double value0, double value1, int size, int approximateSizeOfPossibleMoves=1000, bool discardOneSimulationGobans=false);
    bool saveToFile(const std::string &filename, bool newFile = true);
    bool loadFromFile(const std::string &filename, bool discardNonBeginningGobans=false);
    bool addFromFile(const std::string &filename, bool discardNonBeginningGobans=false);
    double valueForThisMove(const Goban &goban, const Location move, double &value0, double &value1) ;
    double valueForThisMove(const GobanKey &minKey, const Location minKeyMove, double &value0, double &value1) ;
    void clear();
    bool chooseMove(const Goban & _goban, Location &location, double *prediction=0, bool display=true, bool penalizeUncertainty=true) ;
    bool chooseAMoveRandomly(const Goban & _goban, Location &location, bool moreDeterministic) ;
    bool chooseAMoveWithUCT(const Goban & _goban, Location &location, double p2Meta=1.) ;
    void getAllGobanKeyAndMoves(Vector<GobanKey> &keys, Vector<Location> &moves);
    /** only for debug of openingZ generated by yizao ('s hand!!) */
    void showAllEntries() ;

    /** Save all the positions to a set of sgf files, with "destinationFileName" as prefix, then the number of the position
    (depth first search in the database). In "destinationFileName.scores" are saved the estimated values (for black player). 
    These estimated values correspond to the discounted (by lambda) average of MoGo's estimates of the position and the estimates of descendant positions.*/
    void saveToSGF(const char *destinationFileName, double lambda);
  private:
    GobanKey getRepresentative(const Goban &_goban, int &nbRotations, bool &useSymetry);
    Location transformMove(const Location move, int nbRotations, bool useSymetry);
    Location untransformMove(const Location move, int nbRotations, bool useSymetry);

    /** See saveToSGF description */
    double computePositionEstimates(double lambda, double priorPositionEstimate, const GobanKey &keys, MoGoHashMap(GobanKey, double, hashGobanKey, equalGobanKey) &allPositionValues, MoGoHashMap(GobanKey, double, hashGobanKey, equalGobanKey) &allPositionWeights);
    void iterativeMarkPositions(const GobanKey &key, MoGoHashMap(GobanKey, int, hashGobanKey, equalGobanKey) &visitedNodes);

    MoGoHashMap(GobanKey, MoGoHashMap(int, int, hashInt, equalInt), hashGobanKey, equalGobanKey) allGobans;
    //     Vector<Vector<Vector<double> > > values;
    //     Vector<> gobanMoveToValueIndexes;
    Vector<Vector<double> >values;
    int nbGobans;
    bool useOldFormat;
    Goban referenceGoban;
    static int minimumDatabaseUse;
  };

}

#endif
